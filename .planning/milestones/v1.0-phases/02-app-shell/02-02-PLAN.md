---
phase: 02-app-shell
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/client/App.tsx
  - src/client/components/JoinScreen.tsx
  - src/client/components/SessionScreen.tsx
  - src/client/components/ThemeToggle.tsx
  - src/client/lib/theme.ts
  - src/client/__tests__/JoinScreen.test.tsx
  - src/client/__tests__/SessionScreen.test.tsx
  - src/client/__tests__/theme.test.ts
autonomous: true
requirements:
  - SHELL-03
  - JOIN-01
  - JOIN-02
  - JOIN-03

must_haves:
  truths:
    - "User can type their name in a text field on the join screen"
    - "User can select leader or follower role"
    - "User can type a session code and tap Join"
    - "After joining, the screen shows the session code, user's name, role, and connected users"
    - "All buttons and inputs are at least 44px tall"
    - "User can toggle between warm-dark and OLED-black themes via a persistent corner icon"
    - "Name is pre-filled from localStorage on return visits"
    - "Validation error appears only after tapping Join with empty fields"
  artifacts:
    - path: "src/client/components/JoinScreen.tsx"
      provides: "Join form with name, role selection, session code, join button"
      contains: "JoinScreen"
    - path: "src/client/components/SessionScreen.tsx"
      provides: "Post-join connected state showing session info and presence"
      contains: "SessionScreen"
    - path: "src/client/components/ThemeToggle.tsx"
      provides: "Corner icon button toggling warm-dark / OLED-black"
      contains: "ThemeToggle"
    - path: "src/client/lib/theme.ts"
      provides: "Theme state management with localStorage persistence"
      contains: "applyTheme"
    - path: "src/client/App.tsx"
      provides: "Root component routing between JoinScreen and SessionScreen"
      contains: "JoinScreen"
  key_links:
    - from: "src/client/App.tsx"
      to: "src/client/components/JoinScreen.tsx"
      via: "conditional render when not joined"
      pattern: "JoinScreen"
    - from: "src/client/App.tsx"
      to: "src/client/components/SessionScreen.tsx"
      via: "conditional render when joined"
      pattern: "SessionScreen"
    - from: "src/client/components/SessionScreen.tsx"
      to: "src/client/use-deadsync.ts"
      via: "hook call for WebSocket connection"
      pattern: "useDeadSync"
    - from: "src/client/components/JoinScreen.tsx"
      to: "localStorage"
      via: "name persistence read/write"
      pattern: "localStorage"
    - from: "src/client/lib/theme.ts"
      to: "localStorage"
      via: "theme preference persistence"
      pattern: "glory-theme"
---

<objective>
Build the join screen, post-join session screen, and theme toggle — the three UI surfaces that make the app usable for a musician trying to connect.

Purpose: This is where a musician interacts with the app for the first time. They need to enter their name, pick a role, type a session code, and see that they're connected. Every element must be tappable on an iPad under stage lights.
Output: A working join-to-connected flow with dual dark themes and iPad-friendly touch targets.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-app-shell/02-CONTEXT.md
@.planning/phases/02-app-shell/02-RESEARCH.md
@.planning/phases/02-app-shell/02-01-SUMMARY.md

@src/client/use-deadsync.ts
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 0: Create test scaffolds for components and theme</name>
  <files>src/client/__tests__/JoinScreen.test.tsx, src/client/__tests__/SessionScreen.test.tsx, src/client/__tests__/theme.test.ts</files>
  <action>
Create three test scaffold files. These run RED before implementation (all tests should fail or be skipped) and go GREEN as Tasks 1 and 2 create the production code. Install `@testing-library/user-event` if not already present:

```bash
npm install -D @testing-library/user-event
```

**1. `src/client/__tests__/theme.test.ts`** — Unit tests for theme.ts (SHELL-02):

```typescript
import { describe, it, expect, beforeEach } from "vitest";

// Will import from ../../lib/theme once Task 1 creates it
// import { getTheme, applyTheme, toggleTheme } from "../../lib/theme";

describe("theme", () => {
  beforeEach(() => {
    localStorage.clear();
    document.documentElement.className = "";
  });

  it.todo("getTheme returns warm-dark by default");
  it.todo("getTheme returns stored preference from localStorage");
  it.todo("applyTheme sets .dark class on html element");
  it.todo("applyTheme adds .oled class for oled-black theme");
  it.todo("applyTheme removes .oled class for warm-dark theme");
  it.todo("applyTheme persists preference to localStorage");
  it.todo("toggleTheme switches from warm-dark to oled-black");
  it.todo("toggleTheme switches from oled-black to warm-dark");
  it.todo("getTheme handles localStorage errors gracefully");
});
```

**2. `src/client/__tests__/JoinScreen.test.tsx`** — Component tests for JoinScreen (JOIN-01, JOIN-02, JOIN-03):

```tsx
import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
// import userEvent from "@testing-library/user-event";
// Will import once Task 1 creates the component
// import { JoinScreen } from "../../components/JoinScreen";

describe("JoinScreen", () => {
  it.todo("renders name input field");
  it.todo("renders role selection (leader and follower)");
  it.todo("renders session code input with placeholder hint");
  it.todo("renders Glory branding with soar. tagline");
  it.todo("renders join button");
  it.todo("pre-fills name from localStorage");
  it.todo("shows error when submitting with empty name");
  it.todo("shows error when submitting with empty session code");
  it.todo("does not show error before first submit attempt");
  it.todo("calls onJoin with name, role, and code on valid submit");
  it.todo("saves name to localStorage on successful join");
  it.todo("defaults role to follower");
});
```

**3. `src/client/__tests__/SessionScreen.test.tsx`** — Component tests for SessionScreen:

```tsx
import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
// Will import once Task 2 creates the component
// import { SessionScreen } from "../../components/SessionScreen";

// Mock useDeadSync hook
vi.mock("../../use-deadsync", () => ({
  useDeadSync: vi.fn().mockReturnValue({
    connected: true,
    sessionState: { users: [], liveSongIndex: 0, setlist: [] },
    myUser: null,
    isLeader: false,
    leaderDisconnected: false,
    actions: { join: vi.fn(), setSong: vi.fn(), browse: vi.fn(), goLive: vi.fn(), transferLead: vi.fn() },
  }),
}));

describe("SessionScreen", () => {
  it.todo("renders session code");
  it.todo("renders user name and role");
  it.todo("renders connection indicator");
  it.todo("shows green dot when connected");
  it.todo("shows red dot when disconnected");
  it.todo("renders connected users list");
  it.todo("calls actions.join on mount");
  it.todo("shows leader badge when user is leader");
});
```

Each file uses `it.todo()` so tests are recognized by vitest but marked pending. As Tasks 1 and 2 implement the production code, the executor will un-todo the tests and fill in assertions.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx vitest run src/client/__tests__/theme.test.ts src/client/__tests__/JoinScreen.test.tsx src/client/__tests__/SessionScreen.test.tsx</automated>
    <manual>All three test files exist, vitest recognizes them, all tests show as "todo" (pending)</manual>
  </verify>
  <done>Three test scaffold files exist with todo tests covering theme (SHELL-02), JoinScreen (JOIN-01/02/03), and SessionScreen. Vitest runs them without errors. @testing-library/user-event is installed.</done>
</task>

<task type="auto">
  <name>Task 1: Create theme system and join screen</name>
  <files>src/client/lib/theme.ts, src/client/components/ThemeToggle.tsx, src/client/components/JoinScreen.tsx</files>
  <action>
Create three files:

**1. `src/client/lib/theme.ts`** — Theme state management:

```typescript
export type Theme = "warm-dark" | "oled-black";

export function getTheme(): Theme {
  try {
    const stored = localStorage.getItem("glory-theme");
    if (stored === "warm-dark" || stored === "oled-black") return stored;
  } catch { /* swallow */ }
  return "warm-dark";
}

export function applyTheme(theme: Theme): void {
  try { localStorage.setItem("glory-theme", theme); } catch { /* swallow */ }
  const html = document.documentElement;
  html.classList.add("dark");
  html.classList.toggle("oled", theme === "oled-black");
}

export function toggleTheme(): Theme {
  const current = getTheme();
  const next: Theme = current === "warm-dark" ? "oled-black" : "warm-dark";
  applyTheme(next);
  return next;
}
```

Wrap all localStorage calls in try/catch per research pitfall #6 (Safari private browsing).

**2. `src/client/components/ThemeToggle.tsx`** — Persistent corner toggle:

A small icon button fixed to the top-right corner. Toggles between warm-dark and OLED-black. Uses a simple sun/moon metaphor or similar — Claude's discretion on exact icon (use inline SVG, no icon library needed). Must be 44x44px minimum tap target per SHELL-03.

The button should:
- Call `toggleTheme()` from theme.ts on tap
- Update its own visual state to reflect the current theme
- Use `useState` initialized from `getTheme()`
- Be positioned `fixed top-3 right-3 z-50` so it's always accessible
- Be subtle — `text-text-muted hover:text-text-secondary` — not attention-grabbing

**3. `src/client/components/JoinScreen.tsx`** — Single-page join form:

Per user decisions (LOCKED — do not deviate):
- All fields visible on one screen: name, role, session code, join button
- No multi-step wizard
- Name pre-filled from localStorage (`glory-name` key), editable
- Role selection: leader or follower (Claude's discretion on UX — cards, toggle, or segmented control; whatever fits the single-page layout)
- Session code field with placeholder hint: `scarlet-042`
- Light validation: error only shows after tapping Join, not inline
- Branding: "Glory" app name with tagline "soar." visible on join screen

Props interface:
```typescript
interface JoinScreenProps {
  onJoin: (name: string, role: UserRole, code: string) => void;
}
```

Import `UserRole` from `../../shared/protocol`.

All interactive elements (inputs, buttons, role selector) must have `min-h-[44px]` for iPad tap targets (SHELL-03). Inputs should use `text-lg` or larger for readability. Use Tailwind classes from the theme — `bg-surface-raised` for input backgrounds, `text-text-primary` for text, `bg-interactive` for the join button, `border-border` for borders, `border-border-focus` for focus rings.

The join button should be prominent: full-width, gold background (`bg-interactive`), large text, clearly the primary action.

Error state: a single error message below the join button, `text-status-disconnected`, shown only when validation fails on submit.

Layout: centered on screen, max-width container (~400px), vertically stacked fields with generous spacing (`space-y-4` or similar). The Glory branding at the top.

**After creating the production files**, update the test scaffolds from Task 0:
- In `src/client/__tests__/theme.test.ts`: uncomment the import, replace each `it.todo(...)` with a real test that imports from `../../lib/theme` and asserts behavior.
- In `src/client/__tests__/JoinScreen.test.tsx`: uncomment imports, replace each `it.todo(...)` with a real test that renders `JoinScreen` and asserts form behavior using `@testing-library/react` and `@testing-library/user-event`.

All todo tests in those two files must become passing assertions before this task is done.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx tsc --noEmit && npx vite build && npx vitest run src/client/__tests__/theme.test.ts src/client/__tests__/JoinScreen.test.tsx</automated>
    <manual>Files exist at expected paths, TypeScript compiles, Vite build succeeds, theme and JoinScreen tests pass</manual>
  </verify>
  <done>theme.ts exports getTheme/applyTheme/toggleTheme with localStorage persistence. ThemeToggle renders a 44px corner button. JoinScreen renders name/role/code/join with branding, localStorage name persistence, and post-submit validation. Theme and JoinScreen tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create session screen and wire App.tsx routing</name>
  <files>src/client/components/SessionScreen.tsx, src/client/App.tsx</files>
  <action>
Create SessionScreen and rewrite App.tsx to route between screens.

**1. `src/client/components/SessionScreen.tsx`** — Post-join connected state:

Per user decisions (LOCKED):
- Shows: session code, your name, your role, who else is connected
- No song viewer placeholder — this is a holding state until Phase 3
- Presence updates are silent — no toasts, banners, sounds, badges
- Subtle connection indicator (small dot/icon) that changes color on WebSocket drop/reconnect
- **Zero interruptions during performance**

This component calls `useDeadSync` with `host: window.location.host` and `room: code`. On mount, it calls `actions.join(name, role)` via `useEffect` (run once).

Props:
```typescript
interface SessionScreenProps {
  name: string;
  role: UserRole;
  code: string;
}
```

Display layout:
- Session code displayed prominently at top (leader needs to show others how to join — Claude's discretion on prominence)
- Your name and role shown clearly
- Connected users list from `sessionState.users` — show each user's name and role. The current user should be distinguishable (e.g., "(you)" suffix or different styling)
- Connection indicator: a small colored dot — green (`status-connected`) when connected, red (`status-disconnected`) when disconnected. Use the `connected` value from `useDeadSync`. Position it subtly (header area or near the session code)
- Leader badge: if you're the leader, show it clearly. Use `isLeader` from the hook.

The `leaderDisconnected` state from the hook: if truthy, show a subtle indicator that the leader dropped (not a banner — just a muted text note in the status area).

All interactive elements 44px minimum. Body text in `text-text-primary` (warm cream). Secondary info in `text-text-secondary`.

**After creating SessionScreen and updating App.tsx**, update the test scaffold from Task 0:
- In `src/client/__tests__/SessionScreen.test.tsx`: uncomment imports, replace each `it.todo(...)` with a real test that renders `SessionScreen` with mock `useDeadSync` and asserts rendering behavior.

All todo tests in that file must become passing assertions before this task is done.

**2. Rewrite `src/client/App.tsx`** — Screen routing + theme initialization:

```tsx
import { useState, useEffect } from "react";
import { JoinScreen } from "./components/JoinScreen";
import { SessionScreen } from "./components/SessionScreen";
import { ThemeToggle } from "./components/ThemeToggle";
import { applyTheme, getTheme } from "./lib/theme";
import type { UserRole } from "../shared/protocol";

interface JoinConfig {
  name: string;
  role: UserRole;
  code: string;
}

export function App() {
  const [joinConfig, setJoinConfig] = useState<JoinConfig | null>(null);

  // Apply saved theme on mount
  useEffect(() => {
    applyTheme(getTheme());
  }, []);

  function handleJoin(name: string, role: UserRole, code: string) {
    setJoinConfig({ name, role, code });
  }

  return (
    <>
      <ThemeToggle />
      {joinConfig ? (
        <SessionScreen
          name={joinConfig.name}
          role={joinConfig.role}
          code={joinConfig.code}
        />
      ) : (
        <JoinScreen onJoin={handleJoin} />
      )}
    </>
  );
}
```

Key pattern: `SessionScreen` only mounts after join, so `useDeadSync` only creates a WebSocket after the user submits. This avoids the pitfall of connecting before the user has entered their info.

Theme initialization: `applyTheme(getTheme())` on mount ensures the `.dark` and possibly `.oled` classes are set on `<html>` before first render. The `index.html` already has `class="dark"` as a default, but the OLED class needs to be applied from localStorage.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx tsc --noEmit && npx vite build && npx vitest run</automated>
    <manual>Run `npx partykit dev`, visit http://localhost:1977. See join screen with Glory branding, enter name/role/code, tap Join. App transitions to session screen showing connection status.</manual>
  </verify>
  <done>SessionScreen renders post-join state with presence, connection indicator, and session info. App.tsx conditionally renders JoinScreen or SessionScreen based on join state. Theme toggle works in both screens. All tap targets are 44px minimum. Vite build succeeds. All tests pass including theme, JoinScreen, and SessionScreen test suites.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no type errors
2. `npx vite build` — build succeeds
3. `npx vitest run` — existing tests pass
4. Join screen shows: Glory branding, name field (pre-filled if returning), role selector, session code field, join button
5. Tapping Join with empty fields shows error message
6. After joining, session screen shows session code, name, role, presence list, connection indicator
7. Theme toggle switches between warm-dark and OLED-black
8. All buttons and inputs are >= 44px tall
</verification>

<success_criteria>
- A musician can enter name, pick role, type session code, and tap Join
- After joining, they see who's connected and their connection status
- Name persists in localStorage across visits
- Theme preference persists across visits
- Every interactive element is 44px minimum for iPad tapping
- No toasts, banners, sounds, or interruptions — zero noise
</success_criteria>

<output>
After completion, create `.planning/phases/02-app-shell/02-02-SUMMARY.md`
</output>
