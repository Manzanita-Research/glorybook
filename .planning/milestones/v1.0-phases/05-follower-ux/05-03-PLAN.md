---
phase: 05-follower-ux
plan: 03
type: execute
wave: 1
depends_on: [05-02]
files_modified:
  - src/server/deadsync-server.ts
  - src/client/use-deadsync.ts
  - src/server/__tests__/deadsync-server.test.ts
  - src/client/__tests__/PresenceList.test.tsx
  - src/client/__tests__/SessionScreen.test.tsx
autonomous: true
requirements: [PRES-01, PRES-02, FOLL-01, FOLL-02, FOLL-03, FOLL-04]
gap_closure: true

must_haves:
  truths:
    - "Every connected musician can see who else is in the session, including the leader"
    - "The presence list shows all users — both the person viewing it AND every other connected user"
    - "Presence dots correctly show green for live users and gold for browsing users"
  artifacts:
    - path: "src/server/deadsync-server.ts"
      provides: "Server that reliably includes all connected users in state messages"
    - path: "src/client/use-deadsync.ts"
      provides: "Hook that maintains complete user list across state updates"
  key_links:
    - from: "src/server/deadsync-server.ts"
      to: "src/client/use-deadsync.ts"
      via: "state message with users array"
      pattern: "users.*Array\\.from"
    - from: "src/client/components/PresenceList.tsx"
      to: "sessionState.users"
      via: "users prop passed through SetlistDrawer"
      pattern: "users\\.map"
---

<objective>
Fix the presence list so all connected users appear — including the leader.

Purpose: UAT Test 8 found that the leader (Jerry) is missing from the presence list when viewed by the follower (Bobby). The root cause is likely a race condition between `onConnect` and `handleJoin` where the server's in-memory users Map doesn't yet contain the leader when the follower's state message is built, OR a timing issue where a stale `state` message overwrites a richer one on the client. After fixing this, verify Test 9 (presence dots for live vs browsing) works correctly.
Output: Server and/or hook changes that guarantee all connected users appear in the presence list. Verified with tests.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-follower-ux/05-RESEARCH.md
@.planning/phases/05-follower-ux/05-02-SUMMARY.md
@.planning/phases/05-follower-ux/05-UAT.md
@src/server/deadsync-server.ts
@src/client/use-deadsync.ts
@src/client/components/PresenceList.tsx
@src/client/components/SetlistDrawer.tsx
@src/client/components/SessionScreen.tsx
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Investigate and fix leader missing from presence list</name>
  <files>
    src/server/deadsync-server.ts
    src/client/use-deadsync.ts
    src/server/__tests__/deadsync-server.test.ts
  </files>
  <action>
**Investigation:** The presence list shows only Bobby (follower) — Jerry (leader) is missing. Trace the data flow from server to client to find the root cause. There are several candidate causes to check in order:

**Candidate 1 — `onConnect` state overwrites `handleJoin` state:**
The server sends a `state` message in BOTH `onConnect` (line 177-179) AND at the end of `handleJoin` (line 358-360). If the `onConnect` state message for the follower (Bobby) arrives at a time when the users Map only has incomplete data, and somehow this stale state overwrites the richer state from `handleJoin`, the leader could be missing.

Check the exact ordering: `onConnect` fires immediately when Bobby connects, sending state with users as they exist at that moment. Then Bobby's `join` message is processed by `handleJoin`, which adds Bobby to users and sends a NEW `state` with all users. The second state should overwrite the first. Verify this is happening correctly.

**Candidate 2 — Server hibernation clearing users Map:**
If PartyKit with `hibernate: true` wakes the server between Jerry joining and Bobby joining, the in-memory `users` Map resets to empty (it's never persisted). `onStart()` restores `meta` (sessionCode, liveIndex, leaderId) but NOT users. Jerry would effectively vanish from the users list even though their WebSocket is still alive.

Check if this happens in local `partykit dev`. If hibernation doesn't fire locally, this isn't the UAT bug, but it's a latent bug that will happen in production on Cloudflare.

**Candidate 3 — Client-side state handler race:**
In the hook, the `state` case (line 138-146) calls `setSessionState(msg.state)` which replaces the entire state. If two `state` messages arrive and React batches them, only the last one applies. Verify the last `state` message is always the one with the most complete user list.

**Fix approach — belt and suspenders:**

1. **Server: Remove the `state` message from `onConnect`.** The `onConnect` fires before the client has sent a `join` message, so the user isn't in the users Map yet. The state sent here is always stale (missing the connecting user). Instead, let `handleJoin` be the sole sender of the initial `state`. This eliminates the race between two `state` messages.

   In `onConnect` (line 176-179), remove the `getState()` call and `send()`. The connecting client will get their state when they send the `join` message and `handleJoin` responds.

   This is safe because:
   - The client always sends `join` immediately after connecting (SessionScreen.useEffect calls actions.join on mount)
   - On reconnect, the `open` handler in the hook also sends a `join` with `reconnecting: true`
   - No client code relies on receiving state before join

2. **Server: In `handleJoin`, ensure the broadcast of `user-joined` happens AFTER the user is fully added.** Currently this is already the case (line 340 sets the user, line 347 broadcasts). No change needed here.

3. **Hook: In the `user-joined` handler (lines 159-169), make the deduplication more robust.** Currently it filters out any existing user with the same id, then appends. This is correct. No change needed.

4. **Test the fix** by adding or updating a server test that verifies:
   - After two users join (leader then follower), the state sent to the follower contains BOTH users
   - The `onConnect` does NOT send a `state` message (since we removed it)
   - Read existing tests in `src/server/__tests__/deadsync-server.test.ts` and add test cases as appropriate

**Important:** After making the server change, verify that `onConnect` NOT sending state doesn't break any existing test expectations. If existing tests expect a `state` message on connect, update them to expect state only after the `join` message.
  </action>
  <verify>
    <automated>npx vitest run src/server/__tests__/deadsync-server.test.ts --reporter=verbose</automated>
    <manual>Start partykit dev, open two tabs, join as Jerry (leader) and Bobby (follower). Open setlist drawer in Bobby's tab. Verify both Jerry and Bobby appear in presence list.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Server no longer sends premature state on connect. State is sent only after join, guaranteeing all users are included. Both leader and follower appear in the presence list. Server tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Verify presence dots show live vs browsing status (UAT Test 9)</name>
  <files>
    src/client/__tests__/PresenceList.test.tsx
    src/client/__tests__/SessionScreen.test.tsx
  </files>
  <action>
**Context:** UAT Test 9 (presence dots for live vs browsing) was skipped because Test 8 blocked it — only one user was visible. Now that Test 8 is fixed and all users appear, verify Test 9 works correctly.

**Verification steps:**

1. **Review existing PresenceList tests** in `src/client/__tests__/PresenceList.test.tsx`. Confirm there are already tests for:
   - Green dot (`bg-status-connected`) for users with `isLive: true`
   - Gold dot (`bg-accent-gold`) for users with `isLive: false`
   - These tests should already exist from 05-02. If they pass, Test 9 is covered.

2. **Add an integration-level test** in `src/client/__tests__/SessionScreen.test.tsx` that specifically covers the end-to-end scenario:
   - Mock `useDeadSync` returning two users: Jerry (leader, isLive: true) and Bobby (follower, isLive: false — browsing)
   - Open the setlist drawer
   - Verify Jerry's name appears with a green dot (bg-status-connected)
   - Verify Bobby's name appears with a gold dot (bg-accent-gold)
   - This test directly mirrors UAT Test 9's success criteria

3. **Run the full test suite** to confirm no regressions from Task 1.

**Note:** If the existing PresenceList unit tests already cover dot colors for both states, the main value here is the SessionScreen integration test confirming data flows correctly from the hook through SetlistDrawer to PresenceList.
  </action>
  <verify>
    <automated>npx vitest run --reporter=verbose</automated>
    <sampling_rate>run after this task commits</sampling_rate>
  </verify>
  <done>Presence dots correctly show green for live users and gold for browsing users. Integration test confirms data flows from useDeadSync through to PresenceList rendering. Full test suite passes.</done>
</task>

</tasks>

<verification>
- [ ] `npx vitest run` — full test suite passes
- [ ] Opening setlist drawer shows ALL connected users (leader and followers)
- [ ] Leader is marked with "(lead)" label
- [ ] Live users show green dots, browsing users show gold dots
- [ ] No premature state message from server on connect (state only after join)
- [ ] Existing functionality (Go Live, browse-away border, slide animation) still works
</verification>

<success_criteria>
- Both leader and follower appear in the presence list (UAT Test 8 fixed)
- Presence dots correctly reflect live vs browsing status (UAT Test 9 verified)
- Server sends state only after join, eliminating the race condition
- All existing tests pass with no regressions
- Full test suite green
</success_criteria>

<output>
After completion, create `.planning/phases/05-follower-ux/05-03-SUMMARY.md`
</output>
