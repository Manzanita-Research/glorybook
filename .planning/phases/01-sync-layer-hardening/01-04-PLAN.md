---
phase: 01-sync-layer-hardening
plan: 04
type: tdd
wave: 3
depends_on:
  - 02
  - 03
files_modified:
  - src/server/__tests__/deadsync-server.test.ts
  - src/client/__tests__/use-deadsync.test.ts
  - vitest.config.ts
  - package.json
autonomous: true
requirements:
  - SYNC-01
  - SYNC-02
  - SYNC-03
  - SYNC-04
  - SYNC-05
must_haves:
  truths:
    - "Server correctly handles join, set-song, browse, go-live, set-setlist, transfer-lead messages"
    - "Server waits 30 seconds before promoting on leader disconnect"
    - "Server reclaims leadership for reconnecting leader"
    - "Hook message handler uses current isLive value (not stale closure)"
    - "All tests pass with vitest"
  artifacts:
    - path: "src/server/__tests__/deadsync-server.test.ts"
      provides: "Server unit tests covering all handlers and grace period"
      min_lines: 100
    - path: "src/client/__tests__/use-deadsync.test.ts"
      provides: "Hook unit tests covering stale closure fix and reconnect"
      min_lines: 50
    - path: "vitest.config.ts"
      provides: "Vitest configuration"
  key_links:
    - from: "src/server/__tests__/deadsync-server.test.ts"
      to: "src/server/deadsync-server.ts"
      via: "imports and tests server class"
      pattern: "import.*deadsync-server"
    - from: "src/client/__tests__/use-deadsync.test.ts"
      to: "src/client/use-deadsync.ts"
      via: "imports and tests hook"
      pattern: "import.*use-deadsync"
---

<objective>
Add Vitest and write tests that validate all five success criteria for Phase 1. Tests cover server message handling, leader grace period, storage sharding, stale closure fix, and reconnect behavior.

Purpose: Per CONTEXT.md: "Both automated tests AND manual smoke testing. Automated: unit tests for protocol logic, integration tests for server message handling." This plan creates the automated test suite. The manual smoke test (two browser tabs) is documented but not automated — it requires partykit dev and a browser, which is Phase 2 territory.

Output: Vitest config, server tests, hook tests. All pass.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
@/Users/jem/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-sync-layer-hardening/01-CONTEXT.md
@.planning/phases/01-sync-layer-hardening/01-RESEARCH.md
@.planning/phases/01-sync-layer-hardening/01-02-SUMMARY.md
@.planning/phases/01-sync-layer-hardening/01-03-SUMMARY.md
@src/server/deadsync-server.ts
@src/client/use-deadsync.ts
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Vitest and write server tests</name>
  <files>vitest.config.ts, package.json, src/server/__tests__/deadsync-server.test.ts</files>
  <action>
**1. Install Vitest:**
```bash
cd /Users/jem/code/manzanita-research/glorybook && npm install --save-dev vitest @testing-library/react @testing-library/react-hooks jsdom
```

Add test script to package.json:
```json
"scripts": {
  "test": "vitest run",
  "test:watch": "vitest"
}
```

**2. Create vitest.config.ts:**
```typescript
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    environment: "jsdom",
    globals: true,
  },
});
```

**3. Write server tests in `src/server/__tests__/deadsync-server.test.ts`:**

Create mock objects for `Party.Room`, `Party.Connection`, and `Party.Storage`. The server class can be instantiated directly with a mock room.

**Mock pattern:**
```typescript
function createMockStorage() {
  const store = new Map<string, any>();
  let alarm: number | null = null;
  return {
    get: async <T>(key: string) => store.get(key) as T | undefined,
    put: async (key: string, value: any) => { store.set(key, value); },
    delete: async (key: string | string[]) => {
      const keys = Array.isArray(key) ? key : [key];
      keys.forEach(k => store.delete(k));
    },
    list: async <T>(opts?: { prefix?: string }) => {
      const result = new Map<string, T>();
      for (const [k, v] of store) {
        if (!opts?.prefix || k.startsWith(opts.prefix)) result.set(k, v);
      }
      return result;
    },
    setAlarm: async (time: number) => { alarm = time; },
    getAlarm: async () => alarm,
    deleteAlarm: async () => { alarm = null; },
    // expose for test assertions:
    _store: store,
    _getAlarm: () => alarm,
  };
}

function createMockRoom(id = "test-room") {
  const storage = createMockStorage();
  const connections = new Map<string, MockConnection>();
  return {
    id,
    storage,
    broadcast: (msg: string, exclude?: string[]) => {
      for (const [id, conn] of connections) {
        if (!exclude?.includes(id)) conn._messages.push(msg);
      }
    },
    getConnection: (id: string) => connections.get(id),
    getConnections: () => connections.values(),
    _connections: connections,
  };
}

function createMockConnection(id: string) {
  return {
    id,
    _messages: [] as string[],
    send: function(msg: string) { this._messages.push(msg); },
    close: () => {},
  };
}
```

**Test cases (each as a describe/it block):**

a) **Join handling:**
   - First user joining as leader gets leader role
   - Second user joining as leader gets demoted to follower
   - Joining sends full state to the joiner
   - Joining broadcasts user-joined to others

b) **Song navigation:**
   - Leader can set song — broadcasts song-changed
   - Non-leader gets error when trying to set song
   - Out-of-range index returns error

c) **Browse and go-live:**
   - Follower browse updates their currentIndex and isLive
   - Go-live snaps follower back to liveIndex

d) **Leader grace period (CRITICAL):**
   - Leader disconnect sets alarm, does NOT immediately promote
   - After alarm fires (call onAlarm), new leader is promoted
   - Promoted leader is the user with earliest joinedAt
   - If leader reconnects before alarm (re-join), they reclaim leadership and alarm is cancelled

e) **Storage sharding:**
   - After setSetlist, songs are stored as individual "song:N" keys
   - getFullSetlist reassembles from sharded keys in correct order
   - No single storage value exceeds 128 KiB (assert on serialized size)

f) **Transfer leadership:**
   - Leader can transfer to another user
   - Old leader becomes follower
   - Non-leader gets error
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx vitest run src/server/__tests__/deadsync-server.test.ts</automated>
  </verify>
  <done>All server tests pass. Tests cover: join, song navigation, browse/go-live, leader grace period (alarm + reclaim), storage sharding, transfer leadership.</done>
</task>

<task type="auto">
  <name>Task 2: Write hook tests for stale closure fix and reconnect</name>
  <files>src/client/__tests__/use-deadsync.test.ts</files>
  <action>
Write tests for the useDeadSync hook focusing on the stale closure fix and reconnect behavior.

**Approach:** Mock PartySocket to control message delivery and connection events. Use `@testing-library/react` hooks testing or `renderHook` to test the hook in isolation.

**Mock PartySocket:**
```typescript
// Mock partysocket module
vi.mock("partysocket", () => {
  return {
    default: vi.fn().mockImplementation(() => {
      const listeners: Record<string, Function[]> = {};
      return {
        id: "mock-connection-id",
        readyState: 1, // WebSocket.OPEN
        addEventListener: (event: string, handler: Function) => {
          (listeners[event] ??= []).push(handler);
        },
        removeEventListener: () => {},
        send: vi.fn(),
        close: vi.fn(),
        // Test helpers:
        _emit: (event: string, data?: any) => {
          listeners[event]?.forEach(fn => fn(data));
        },
        _listeners: listeners,
      };
    }),
  };
});
```

**Test cases:**

a) **Stale closure fix (CRITICAL — Success Criteria #1):**
   - Hook starts with isLive=true
   - User browses away (isLive=false)
   - Server sends song-changed
   - localIndex should NOT update (user is browsing, not live)
   - This is the exact bug that existed before — the test MUST verify the fix

b) **Reconnect re-join:**
   - User joins with name and role
   - Socket fires close event (disconnect)
   - Socket fires open event (reconnect)
   - Hook should automatically send join message with reconnecting=true
   - After receiving state message, should snap to live song

c) **Connection state:**
   - connected starts false
   - After open event, connected is true
   - After close event, connected is false

d) **Actions:**
   - setSong sends correct message
   - browse updates local state and sends message
   - goLive snaps to live index and sends message

Note: Wake Lock tests are deferred to Phase 2 per CONTEXT.md ("Defer reconnect/Wake Lock verification to UI phase"). The Wake Lock utility itself is simple enough to not need unit tests — it's a thin wrapper around the browser API.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx vitest run src/client/__tests__/use-deadsync.test.ts</automated>
  </verify>
  <done>All hook tests pass. Stale closure fix is verified: browsing follower does not follow song-changed. Reconnect re-join is verified: open event triggers join with reconnecting flag.</done>
</task>

</tasks>

<verification>
- `npx vitest run` passes all tests
- Server tests cover join, navigation, browse/go-live, grace period, storage sharding, transfer
- Hook tests verify stale closure fix (browsing follower ignores song-changed)
- Hook tests verify reconnect re-join (open event sends join)
- No test uses real WebSocket connections or PartyKit servers
</verification>

<success_criteria>
All tests pass. The stale closure bug is proven fixed by test. Leader grace period is tested with mock alarm. Storage sharding is tested with mock storage. Reconnect re-join is tested with mock socket events. The five Phase 1 success criteria each have at least one test covering them.
</success_criteria>

<output>
After completion, create `.planning/phases/01-sync-layer-hardening/01-04-SUMMARY.md`
</output>
