---
phase: 01-sync-layer-hardening
plan: 03
type: execute
wave: 2
depends_on:
  - 01
files_modified:
  - src/client/use-deadsync.ts
  - src/client/wake-lock.ts
autonomous: true
requirements:
  - SYNC-02
  - SYNC-04
  - SYNC-05
must_haves:
  truths:
    - "The hook responds correctly to song-changed messages regardless of when isLive changed"
    - "After a WiFi drop, the client reconnects and re-joins the session automatically"
    - "On reconnect, the client snaps to the current live song"
    - "Wake Lock is requested on session join to prevent iPad screen dimming"
    - "Wake Lock is re-acquired when the page becomes visible again"
  artifacts:
    - path: "src/client/use-deadsync.ts"
      provides: "React hook with stale closure fix, reconnect re-join, and Wake Lock"
      exports: ["useDeadSync"]
    - path: "src/client/wake-lock.ts"
      provides: "Wake Lock utility module"
      exports: ["requestWakeLock", "releaseWakeLock"]
  key_links:
    - from: "src/client/use-deadsync.ts"
      to: "src/shared/protocol.ts"
      via: "imports message types"
      pattern: "import.*protocol"
    - from: "src/client/use-deadsync.ts"
      to: "src/client/wake-lock.ts"
      via: "imports Wake Lock utilities"
      pattern: "import.*wake-lock"
    - from: "src/client/use-deadsync.ts"
      to: "partysocket"
      via: "PartySocket WebSocket client"
      pattern: "import.*partysocket"
---

<objective>
Fix the React hook: eliminate the stale closure bug, add automatic reconnect re-join with snap-to-live, and integrate Wake Lock API to prevent iPad screen dimming.

Purpose: The hook is the client's interface to the sync layer. The stale closure bug means followers don't actually follow (SYNC-02). No reconnect re-join means WiFi drops break the session (SYNC-05). No Wake Lock means iPads on music stands go dark mid-song (SYNC-04).

Output: Rewritten `src/client/use-deadsync.ts` and new `src/client/wake-lock.ts` utility.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-sync-layer-hardening/01-CONTEXT.md
@.planning/phases/01-sync-layer-hardening/01-RESEARCH.md
@.planning/phases/01-sync-layer-hardening/01-01-SUMMARY.md
@src/client/use-deadsync.ts
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Wake Lock utility module</name>
  <files>src/client/wake-lock.ts</files>
  <action>
Create `src/client/wake-lock.ts` with a small, focused Wake Lock utility.

```typescript
// Wake Lock utility — keeps iPad screens awake on music stands
// Per CONTEXT.md: "Request Wake Lock API on session join — iPads on music stands should never sleep. Always on, no user toggle."

let wakeLockSentinel: WakeLockSentinel | null = null;

export async function requestWakeLock(): Promise<boolean> {
  if (!("wakeLock" in navigator)) return false;
  try {
    wakeLockSentinel = await navigator.wakeLock.request("screen");
    // Re-acquire when page becomes visible again (Wake Lock releases on tab switch / screen lock)
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return true;
  } catch {
    return false;
  }
}

export async function releaseWakeLock(): Promise<void> {
  document.removeEventListener("visibilitychange", handleVisibilityChange);
  if (wakeLockSentinel) {
    await wakeLockSentinel.release();
    wakeLockSentinel = null;
  }
}

async function handleVisibilityChange() {
  if (document.visibilityState === "visible" && !wakeLockSentinel) {
    try {
      wakeLockSentinel = await navigator.wakeLock.request("screen");
    } catch {
      // Silently fail — browser may deny in some states
    }
  }
}
```

Keep it simple. No event emitters, no state management. Just request/release with automatic re-acquisition.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx tsc --noEmit src/client/wake-lock.ts</automated>
  </verify>
  <done>Wake Lock utility compiles. Exports requestWakeLock and releaseWakeLock. Re-acquires on visibilitychange.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite useDeadSync hook with stale closure fix and reconnect</name>
  <files>src/client/use-deadsync.ts</files>
  <action>
Rewrite `src/client/use-deadsync.ts` to fix the stale closure bug, add reconnect re-join, and integrate Wake Lock.

**1. Fix stale closure (the critical bug):**

The current `handleServerMessage` is a `useCallback` that captures `isLive` from its closure. It's registered as a listener in a `useEffect([host, room])` that only runs on mount. After mount, the handler never sees updated `isLive`.

Fix: Use `useRef` to hold the latest `isLive` value, and read from the ref inside the message handler.

```typescript
const isLiveRef = useRef(true);
const [isLive, setIsLive] = useState(true);

// Keep ref in sync with state
useEffect(() => { isLiveRef.current = isLive; }, [isLive]);

// In message handler — read from ref, not closure:
case "song-changed":
  setSessionState(prev => prev ? { ...prev, liveIndex: msg.index } : prev);
  if (isLiveRef.current) {
    setLocalIndex(msg.index);
  }
  break;
```

Also use refs for `sessionState` where needed (e.g., in browse action that reads `sessionState.liveIndex`).

**2. Reconnect re-join:**

Store the user's name and role so we can re-join after reconnect. The `open` event fires on EVERY connection (initial and reconnect). On open, always send a join message.

```typescript
const userInfoRef = useRef<{ name: string; role: UserRole } | null>(null);

// In the join action:
join: (name, role) => {
  userInfoRef.current = { name, role };
  send({ type: "join", name, role });
},

// In the socket open handler:
socket.addEventListener("open", () => {
  setConnected(true);
  setConnectionId(socket.id);
  // Re-join on reconnect (not just first connect)
  if (userInfoRef.current) {
    send({
      type: "join",
      name: userInfoRef.current.name,
      role: userInfoRef.current.role,
      reconnecting: true,
    });
  }
});
```

Per CONTEXT.md: "On successful reconnect, snap to the current live song automatically." When receiving the `state` message after reconnect, always snap to live:

```typescript
case "state":
  setSessionState(msg.state);
  // Always snap to live on state sync (covers both initial connect and reconnect)
  setLocalIndex(msg.state.liveIndex);
  setIsLive(true);
  break;
```

**3. Handle leader-disconnected message:**

```typescript
case "leader-disconnected":
  // Store for UI to show subtle indicator (Phase 2 will render this)
  setLeaderDisconnected({ graceSeconds: msg.graceSeconds });
  break;
```

Add `leaderDisconnected` to the return value of the hook so UI can show a subtle indicator later.

**4. Integrate Wake Lock:**

Import from `./wake-lock.ts`. Request on first successful join, release on disconnect:

```typescript
// After sending join for the first time (not reconnect):
join: async (name, role) => {
  userInfoRef.current = { name, role };
  send({ type: "join", name, role });
  await requestWakeLock();
},

// In disconnect action:
disconnect: () => {
  releaseWakeLock();
  socketRef.current?.close();
},

// Also release on unmount (cleanup):
return () => {
  releaseWakeLock();
  socket.close();
};
```

**5. PartySocket configuration:**

Configure PartySocket for reliable reconnection (the defaults are already good but be explicit):

```typescript
const socket = new PartySocket({
  host,
  room,
  // PartySocket defaults: maxRetries: Infinity, maxReconnectionDelay: 10000
  // These match CONTEXT.md "never give up reconnecting"
});
```

**6. Export interface update:**

Add to the return type:
- `leaderDisconnected: { graceSeconds: number } | null` — for UI to show subtle indicator
- Keep all existing return values

**7. Remove stale patterns:**
- Remove the `useCallback` wrapper on `handleServerMessage` — define it as a regular function inside the `useEffect` that creates the socket, or use a ref-based pattern
- The message handler should be defined inline in the `useEffect` or via a ref that always points to the latest handler

The cleanest pattern: define the message handler inside the `useEffect` body and use refs for any state it needs to read:

```typescript
useEffect(() => {
  const socket = new PartySocket({ host, room });
  socketRef.current = socket;

  socket.addEventListener("message", (event) => {
    const msg: ServerMessage = JSON.parse(event.data);
    // This handler is created once but reads current values via refs
    switch (msg.type) {
      case "song-changed":
        setSessionState(prev => prev ? { ...prev, liveIndex: msg.index } : prev);
        if (isLiveRef.current) setLocalIndex(msg.index);
        break;
      // ... other cases
    }
  });

  socket.addEventListener("open", () => { /* ... */ });
  socket.addEventListener("close", () => setConnected(false));

  return () => {
    releaseWakeLock();
    socket.close();
    socketRef.current = null;
  };
}, [host, room]);
```
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx tsc --noEmit src/client/use-deadsync.ts</automated>
  </verify>
  <done>Hook compiles against new protocol types. Message handler uses refs instead of stale closures. Reconnect sends re-join with reconnecting flag. State sync snaps to live. Wake Lock requested on join, released on disconnect and unmount. leaderDisconnected exposed in return value.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit src/client/use-deadsync.ts src/client/wake-lock.ts` passes
- No `useCallback` wrapping the message handler (stale closure eliminated)
- `isLiveRef` used in message handler instead of `isLive` from closure
- Socket `open` handler sends join with reconnecting flag if userInfoRef has data
- `state` message handler always snaps to live
- Wake Lock requested on join, released on disconnect
- `leaderDisconnected` in hook return type
</verification>

<success_criteria>
Hook compiles and exports useDeadSync. The stale closure bug is fixed via refs. Reconnect re-join is automatic. Wake Lock is integrated. All new server message types (leader-disconnected) are handled.
</success_criteria>

<output>
After completion, create `.planning/phases/01-sync-layer-hardening/01-03-SUMMARY.md`
</output>
