---
phase: 01-sync-layer-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/protocol.ts
  - src/shared/default-setlist.ts
autonomous: true
requirements:
  - SYNC-01
must_haves:
  truths:
    - "All client-to-server message types are defined with TypeScript discriminated unions"
    - "All server-to-client message types are defined with TypeScript discriminated unions"
    - "The protocol includes a leader-disconnected message for grace period visibility"
    - "The join message supports a reconnecting flag for reconnect re-join"
    - "Song type includes all fields needed for chord chart rendering"
  artifacts:
    - path: "src/shared/protocol.ts"
      provides: "Complete typed protocol for client-server communication"
      exports: ["Song", "Setlist", "SessionUser", "SessionState", "ClientMessage", "ServerMessage", "generateSessionCode"]
    - path: "src/shared/default-setlist.ts"
      provides: "Demo setlist with 8 Dead songs"
      exports: ["DEFAULT_SETLIST"]
  key_links:
    - from: "src/shared/protocol.ts"
      to: "src/server/deadsync-server.ts"
      via: "type imports for message handling"
      pattern: "import.*protocol"
    - from: "src/shared/protocol.ts"
      to: "src/client/use-deadsync.ts"
      via: "type imports for message handling"
      pattern: "import.*protocol"
---

<objective>
Redesign the protocol types from scratch based on what we now know about the sync layer requirements.

Purpose: The protocol is the contract between server and client. Redesigning it first (per user decision in CONTEXT.md) ensures the server and hook rewrites in later plans build on a solid foundation that accounts for reconnect, leader grace periods, and browse/live dual state.

Output: Rewritten `src/shared/protocol.ts` with all message types for both directions, plus validated `src/shared/default-setlist.ts`.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-sync-layer-hardening/01-CONTEXT.md
@.planning/phases/01-sync-layer-hardening/01-RESEARCH.md
@src/shared/protocol.ts
@src/shared/default-setlist.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Redesign protocol message types</name>
  <files>src/shared/protocol.ts</files>
  <action>
Rewrite `src/shared/protocol.ts` from scratch per CONTEXT.md decision ("Protocol should be rethought from scratch"). Keep the core data model types (Song, Setlist, SessionUser, SessionState) but redesign message types.

**Data model types to keep/refine:**
- `Song` — id, title, key, tempo, notes?, chart (markdown string)
- `Setlist` — id, name, songs: Song[]
- `UserRole` — "leader" | "follower"
- `SessionUser` — id, name, role, isLive, currentIndex, joinedAt (NEW: for leader promotion order per CONTEXT.md: "first follower who joined")
- `SessionState` — sessionCode, setlist (metadata only for state message — see below), liveIndex, leaderId, users

**Client -> Server messages (ClientMessage discriminated union):**
- `join` — { type: "join", name: string, role: UserRole, reconnecting?: boolean } — reconnecting flag for re-join after WiFi drop
- `set-song` — { type: "set-song", index: number } — leader advances/retreats
- `browse` — { type: "browse", index: number } — follower browses independently
- `go-live` — { type: "go-live" } — follower snaps back to live song
- `set-setlist` — { type: "set-setlist", setlist: Setlist } — leader loads a setlist
- `transfer-lead` — { type: "transfer-lead", userId: string } — leader hands off
- `request-state` — { type: "request-state" } — ask for full state

**Server -> Client messages (ServerMessage discriminated union):**
- `state` — { type: "state", state: SessionState } — full state sync (includes full setlist with charts — keep it simple per research recommendation)
- `song-changed` — { type: "song-changed", index: number, leaderId: string } — leader moved
- `user-joined` — { type: "user-joined", user: SessionUser }
- `user-left` — { type: "user-left", userId: string }
- `user-updated` — { type: "user-updated", user: SessionUser }
- `leader-changed` — { type: "leader-changed", leaderId: string, leaderName: string }
- `leader-disconnected` — { type: "leader-disconnected", graceSeconds: number } — NEW: tells followers the leader dropped, grace period active
- `error` — { type: "error", message: string, code?: string }

**Keep:** `generateSessionCode()` utility function with Dead song names.

**Important:** Use `export type` for type-only exports. Use `export interface` for data shapes. All message types must be discriminated on `type` field.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx tsc --noEmit src/shared/protocol.ts</automated>
  </verify>
  <done>All protocol types compile without errors. ClientMessage and ServerMessage are discriminated unions. SessionUser includes joinedAt. leader-disconnected message type exists. join message has optional reconnecting flag.</done>
</task>

<task type="auto">
  <name>Task 2: Validate default setlist against new types</name>
  <files>src/shared/default-setlist.ts</files>
  <action>
Update `src/shared/default-setlist.ts` if needed to conform to any changes in the Song or Setlist types from Task 1. The existing 8 Dead songs with real chord charts should be preserved exactly as-is (per CONTEXT.md: "Keep the default setlist with 8 Dead songs and real chord charts").

If SessionUser now includes `joinedAt`, no change needed here (that's a runtime field). If Song type changed field names, update the setlist data to match.

Run `tsc --noEmit` on both files together to confirm they compile.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx tsc --noEmit src/shared/protocol.ts src/shared/default-setlist.ts</automated>
  </verify>
  <done>Default setlist compiles against updated protocol types. All 8 songs preserved with real chord charts.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit src/shared/protocol.ts src/shared/default-setlist.ts` passes
- protocol.ts exports ClientMessage, ServerMessage, SessionState, Song, Setlist, SessionUser, UserRole, generateSessionCode
- ClientMessage includes join with reconnecting? flag
- ServerMessage includes leader-disconnected message type
- SessionUser includes joinedAt field
- default-setlist.ts has 8 songs with non-empty chart fields
</verification>

<success_criteria>
Protocol types compile. All message types for both directions are defined as discriminated unions. The protocol accounts for reconnect (join.reconnecting), leader grace period (leader-disconnected), and browse/live state (browse, go-live messages). Default setlist unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/01-sync-layer-hardening/01-01-SUMMARY.md`
</output>
