---
phase: 02-app-shell
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/client/App.tsx
  - src/client/components/JoinScreen.tsx
  - src/client/components/SessionScreen.tsx
  - src/client/components/ThemeToggle.tsx
  - src/client/lib/theme.ts
autonomous: true
requirements:
  - SHELL-03
  - JOIN-01
  - JOIN-02
  - JOIN-03

must_haves:
  truths:
    - "User can type their name in a text field on the join screen"
    - "User can select leader or follower role"
    - "User can type a session code and tap Join"
    - "After joining, the screen shows the session code, user's name, role, and connected users"
    - "All buttons and inputs are at least 44px tall"
    - "User can toggle between warm-dark and OLED-black themes via a persistent corner icon"
    - "Name is pre-filled from localStorage on return visits"
    - "Validation error appears only after tapping Join with empty fields"
  artifacts:
    - path: "src/client/components/JoinScreen.tsx"
      provides: "Join form with name, role selection, session code, join button"
      contains: "JoinScreen"
    - path: "src/client/components/SessionScreen.tsx"
      provides: "Post-join connected state showing session info and presence"
      contains: "SessionScreen"
    - path: "src/client/components/ThemeToggle.tsx"
      provides: "Corner icon button toggling warm-dark / OLED-black"
      contains: "ThemeToggle"
    - path: "src/client/lib/theme.ts"
      provides: "Theme state management with localStorage persistence"
      contains: "applyTheme"
    - path: "src/client/App.tsx"
      provides: "Root component routing between JoinScreen and SessionScreen"
      contains: "JoinScreen"
  key_links:
    - from: "src/client/App.tsx"
      to: "src/client/components/JoinScreen.tsx"
      via: "conditional render when not joined"
      pattern: "JoinScreen"
    - from: "src/client/App.tsx"
      to: "src/client/components/SessionScreen.tsx"
      via: "conditional render when joined"
      pattern: "SessionScreen"
    - from: "src/client/components/SessionScreen.tsx"
      to: "src/client/use-deadsync.ts"
      via: "hook call for WebSocket connection"
      pattern: "useDeadSync"
    - from: "src/client/components/JoinScreen.tsx"
      to: "localStorage"
      via: "name persistence read/write"
      pattern: "localStorage"
    - from: "src/client/lib/theme.ts"
      to: "localStorage"
      via: "theme preference persistence"
      pattern: "glory-theme"
---

<objective>
Build the join screen, post-join session screen, and theme toggle — the three UI surfaces that make the app usable for a musician trying to connect.

Purpose: This is where a musician interacts with the app for the first time. They need to enter their name, pick a role, type a session code, and see that they're connected. Every element must be tappable on an iPad under stage lights.
Output: A working join-to-connected flow with dual dark themes and iPad-friendly touch targets.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-app-shell/02-CONTEXT.md
@.planning/phases/02-app-shell/02-RESEARCH.md
@.planning/phases/02-app-shell/02-01-SUMMARY.md

@src/client/use-deadsync.ts
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create theme system and join screen</name>
  <files>src/client/lib/theme.ts, src/client/components/ThemeToggle.tsx, src/client/components/JoinScreen.tsx</files>
  <action>
Create three files:

**1. `src/client/lib/theme.ts`** — Theme state management:

```typescript
export type Theme = "warm-dark" | "oled-black";

export function getTheme(): Theme {
  try {
    const stored = localStorage.getItem("glory-theme");
    if (stored === "warm-dark" || stored === "oled-black") return stored;
  } catch { /* swallow */ }
  return "warm-dark";
}

export function applyTheme(theme: Theme): void {
  try { localStorage.setItem("glory-theme", theme); } catch { /* swallow */ }
  const html = document.documentElement;
  html.classList.add("dark");
  html.classList.toggle("oled", theme === "oled-black");
}

export function toggleTheme(): Theme {
  const current = getTheme();
  const next: Theme = current === "warm-dark" ? "oled-black" : "warm-dark";
  applyTheme(next);
  return next;
}
```

Wrap all localStorage calls in try/catch per research pitfall #6 (Safari private browsing).

**2. `src/client/components/ThemeToggle.tsx`** — Persistent corner toggle:

A small icon button fixed to the top-right corner. Toggles between warm-dark and OLED-black. Uses a simple sun/moon metaphor or similar — Claude's discretion on exact icon (use inline SVG, no icon library needed). Must be 44x44px minimum tap target per SHELL-03.

The button should:
- Call `toggleTheme()` from theme.ts on tap
- Update its own visual state to reflect the current theme
- Use `useState` initialized from `getTheme()`
- Be positioned `fixed top-3 right-3 z-50` so it's always accessible
- Be subtle — `text-text-muted hover:text-text-secondary` — not attention-grabbing

**3. `src/client/components/JoinScreen.tsx`** — Single-page join form:

Per user decisions (LOCKED — do not deviate):
- All fields visible on one screen: name, role, session code, join button
- No multi-step wizard
- Name pre-filled from localStorage (`glory-name` key), editable
- Role selection: leader or follower (Claude's discretion on UX — cards, toggle, or segmented control; whatever fits the single-page layout)
- Session code field with placeholder hint: `scarlet-042`
- Light validation: error only shows after tapping Join, not inline
- Branding: "Glory" app name with tagline "soar." visible on join screen

Props interface:
```typescript
interface JoinScreenProps {
  onJoin: (name: string, role: UserRole, code: string) => void;
}
```

Import `UserRole` from `../../shared/protocol`.

All interactive elements (inputs, buttons, role selector) must have `min-h-[44px]` for iPad tap targets (SHELL-03). Inputs should use `text-lg` or larger for readability. Use Tailwind classes from the theme — `bg-surface-raised` for input backgrounds, `text-text-primary` for text, `bg-interactive` for the join button, `border-border` for borders, `border-border-focus` for focus rings.

The join button should be prominent: full-width, gold background (`bg-interactive`), large text, clearly the primary action.

Error state: a single error message below the join button, `text-status-disconnected`, shown only when validation fails on submit.

Layout: centered on screen, max-width container (~400px), vertically stacked fields with generous spacing (`space-y-4` or similar). The Glory branding at the top.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx tsc --noEmit && npx vite build</automated>
    <manual>Files exist at expected paths, TypeScript compiles, Vite build succeeds</manual>
  </verify>
  <done>theme.ts exports getTheme/applyTheme/toggleTheme with localStorage persistence. ThemeToggle renders a 44px corner button. JoinScreen renders name/role/code/join with branding, localStorage name persistence, and post-submit validation.</done>
</task>

<task type="auto">
  <name>Task 2: Create session screen and wire App.tsx routing</name>
  <files>src/client/components/SessionScreen.tsx, src/client/App.tsx</files>
  <action>
Create SessionScreen and rewrite App.tsx to route between screens.

**1. `src/client/components/SessionScreen.tsx`** — Post-join connected state:

Per user decisions (LOCKED):
- Shows: session code, your name, your role, who else is connected
- No song viewer placeholder — this is a holding state until Phase 3
- Presence updates are silent — no toasts, banners, sounds, badges
- Subtle connection indicator (small dot/icon) that changes color on WebSocket drop/reconnect
- **Zero interruptions during performance**

This component calls `useDeadSync` with `host: window.location.host` and `room: code`. On mount, it calls `actions.join(name, role)` via `useEffect` (run once).

Props:
```typescript
interface SessionScreenProps {
  name: string;
  role: UserRole;
  code: string;
}
```

Display layout:
- Session code displayed prominently at top (leader needs to show others how to join — Claude's discretion on prominence)
- Your name and role shown clearly
- Connected users list from `sessionState.users` — show each user's name and role. The current user should be distinguishable (e.g., "(you)" suffix or different styling)
- Connection indicator: a small colored dot — green (`status-connected`) when connected, red (`status-disconnected`) when disconnected. Use the `connected` value from `useDeadSync`. Position it subtly (header area or near the session code)
- Leader badge: if you're the leader, show it clearly. Use `isLeader` from the hook.

The `leaderDisconnected` state from the hook: if truthy, show a subtle indicator that the leader dropped (not a banner — just a muted text note in the status area).

All interactive elements 44px minimum. Body text in `text-text-primary` (warm cream). Secondary info in `text-text-secondary`.

**2. Rewrite `src/client/App.tsx`** — Screen routing + theme initialization:

```tsx
import { useState, useEffect } from "react";
import { JoinScreen } from "./components/JoinScreen";
import { SessionScreen } from "./components/SessionScreen";
import { ThemeToggle } from "./components/ThemeToggle";
import { applyTheme, getTheme } from "./lib/theme";
import type { UserRole } from "../shared/protocol";

interface JoinConfig {
  name: string;
  role: UserRole;
  code: string;
}

export function App() {
  const [joinConfig, setJoinConfig] = useState<JoinConfig | null>(null);

  // Apply saved theme on mount
  useEffect(() => {
    applyTheme(getTheme());
  }, []);

  function handleJoin(name: string, role: UserRole, code: string) {
    setJoinConfig({ name, role, code });
  }

  return (
    <>
      <ThemeToggle />
      {joinConfig ? (
        <SessionScreen
          name={joinConfig.name}
          role={joinConfig.role}
          code={joinConfig.code}
        />
      ) : (
        <JoinScreen onJoin={handleJoin} />
      )}
    </>
  );
}
```

Key pattern: `SessionScreen` only mounts after join, so `useDeadSync` only creates a WebSocket after the user submits. This avoids the pitfall of connecting before the user has entered their info.

Theme initialization: `applyTheme(getTheme())` on mount ensures the `.dark` and possibly `.oled` classes are set on `<html>` before first render. The `index.html` already has `class="dark"` as a default, but the OLED class needs to be applied from localStorage.
  </action>
  <verify>
    <automated>cd /Users/jem/code/manzanita-research/glorybook && npx tsc --noEmit && npx vite build && npx vitest run</automated>
    <manual>Run `npx partykit dev`, visit http://localhost:1977. See join screen with Glory branding, enter name/role/code, tap Join. App transitions to session screen showing connection status.</manual>
  </verify>
  <done>SessionScreen renders post-join state with presence, connection indicator, and session info. App.tsx conditionally renders JoinScreen or SessionScreen based on join state. Theme toggle works in both screens. All tap targets are 44px minimum. Vite build and existing tests pass.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no type errors
2. `npx vite build` — build succeeds
3. `npx vitest run` — existing tests pass
4. Join screen shows: Glory branding, name field (pre-filled if returning), role selector, session code field, join button
5. Tapping Join with empty fields shows error message
6. After joining, session screen shows session code, name, role, presence list, connection indicator
7. Theme toggle switches between warm-dark and OLED-black
8. All buttons and inputs are >= 44px tall
</verification>

<success_criteria>
- A musician can enter name, pick role, type session code, and tap Join
- After joining, they see who's connected and their connection status
- Name persists in localStorage across visits
- Theme preference persists across visits
- Every interactive element is 44px minimum for iPad tapping
- No toasts, banners, sounds, or interruptions — zero noise
</success_criteria>

<output>
After completion, create `.planning/phases/02-app-shell/02-02-SUMMARY.md`
</output>
